package generator

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"path/filepath"

	"github.com/dave/jennifer/jen"
	"github.com/jamesdphillips/graphql/language/ast"
	"github.com/jamesdphillips/graphql/language/location"
)

// Saver represents an item that can write generated types.
type Saver interface {
	Save(f *jen.File) error
}

// DryRun implements Saver interface, omits writing code to disk and logs
// result of render.
type DryRun struct {
	Debug bool
}

// Save runs render and logs results
func (d *DryRun) Save(f *jen.File) error {
	buf := &bytes.Buffer{}
	if err := f.Render(buf); err != nil {
		logger.WithError(err).Error("unable to render generated code")
		return err
	}
	logger.Info("dry-run successful; generated code was rendered without err")
	if d.Debug {
		logger.Print(buf)
	}
	return nil
}

// fileSaver writes generated types to disk given path.
type fileSaver struct {
	sourcePath string
}

// File extension .gql.go is used for generated files
func (s fileSaver) outputPath() string {
	ext := filepath.Ext(s.sourcePath)
	fpath := s.sourcePath[0 : len(s.sourcePath)-len(ext)]
	return fpath + ".gql.go"
}

// Save renders types to disk
func (s fileSaver) Save(f *jen.File) error {
	buf := &bytes.Buffer{}
	if err := f.Render(buf); err != nil {
		return err
	}
	return ioutil.WriteFile(s.outputPath(), buf.Bytes(), 0644)
}

// Generator generates Go code for given type defnitions found in given file.
type Generator struct {
	// Saver handles rendering and persisting generators output.
	Saver
	// Invoker field identifies the caller that invoked generated. Name is
	// included in warning comment at top of generated file.
	Invoker string

	source *GraphQLFile
	jen    *jen.File
}

// New returns new generator given path and name of package resulting file will
// reside.
func New(pkgName string, source *GraphQLFile) Generator {
	return Generator{
		Saver:   fileSaver{sourcePath: source.path},
		Invoker: "graphql/generator package",
		source:  source,
		jen:     jen.NewFile(pkgName),
	}
}

// Run generates code and saves
func (g Generator) Run() error {
	jen := g.jen

	// Warning comment
	jen.HeaderComment(fmt.Sprintf("Code generated by %s. DO NOT EDIT.", g.Invoker))
	jen.Line()

	// Iterate through each definition found in the document and generate
	// appropriate code.
	for _, d := range g.source.Definitions() {
		code := genTypeDefinition(jen, d)
		if code != nil {
			jen.Add(code)
		}
	}

	// Write generated code to disk.
	return g.Save(jen)
}

func genTypeDefinition(f *jen.File, node ast.Node) jen.Code {
	loc := location.GetLocation(node.GetLoc().Source, node.GetLoc().Start)
	logger := logger.WithField("type", node.GetKind()).WithField("line", loc.Line)

	switch defNode := node.(type) {
	case *ast.ScalarDefinition:
		return genScalar(defNode)
	case *ast.ObjectDefinition:
		return genObjectType(defNode)
	case *ast.UnionDefinition:
		return genUnion(defNode)
	case *ast.EnumDefinition:
		return genEnum(defNode)
	case *ast.InterfaceDefinition:
		return genInterface(defNode)
	case *ast.InputObjectDefinition:
		return genInputObject(defNode)
	case *ast.SchemaDefinition:
		return genSchema(defNode)
	case *ast.DirectiveDefinition:
		logger.Warn("unsupported at this time; skipping")
	case *ast.TypeExtensionDefinition:
		logger.Warn("unsupported at this time; skipping")
	default:
		logger.Fatal("unhandled type encountered")
	}
	return nil
}
